リストの使い所
================================================

ここまで、リストの以下の特徴について見てきました。

- ◯番目として、個々の値を扱える
- リストを変更できる

では、そんなリストをプログラミングでどんな時に使うか考えてみましょう。
私たちの身の回りには、リストが使えるシーンが隠れています。

例：ファミリーレストランの会計
--------------------------------

例として、ファミレスでの注文の扱いを考えます。

- 注文があるたびに **商品の金額をリストに追加** します
- 会計時にリストを使って合計金額を算出します

リストを使って、**処理中の値を覚えておく** わけです。

注文を受ける
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

お客さまが入店したら、**空のリスト** を用意します。
お客さまごとに会計をするので、空のリストはお客さまごとに必要です。
話を単純にするために、お客さまは1組だけとします。

変数 ``chumon_kingaku`` で、お客さまの注文金額を表すことにしましょう。

.. code-block:: python

    >>> chumon_kingaku = []

お客さまはドリアとドリンクバーを注文しました。

- ドリア：300円（※金額はすべて税込価格とします）
- ドリンクバー：180円

``chumon_kingaku`` に追加します。

.. code-block:: python

    >>> chumon_kingaku.append(300)
    >>> chumon_kingaku.append(180)

お客さまは食後にデザートを追加で注文しました。
デザートは、プリンとティラミスのセットプレート（400円）です。

.. code-block:: python

    >>> chumon_kingaku.append(400)

会計する
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

お客さまは会計に進みました。
リスト ``chumon_kingaku`` と ``for`` 文を使うと、合計金額が求められます。
最初に合計金額を0円とし、``chumon_kingaku`` の要素（個々の金額）を合計金額に足すことを繰り返します。

.. 別解
    >>> sum(chumon_kingaku)
    880

.. code-block:: python

    >>> goukei_kingaku = 0
    >>> for kakaku in chumon_kingaku:
    ...     goukei_kingaku += kakaku
    ...
    >>> goukei_kingaku  # ((計算された合計金額))
    880

価格それぞれを足すという反復処理の前に、**合計金額を0円としておく** のがポイントです。
0円は実際の合計金額ではありませんが、そこに値を加算していきます。
反復処理が終わったときには、リスト ``chumon_kingaku`` の **要素が1度ずつ足されている** （``0 + 300 + 180 + 400``）ので、
``goukei_kingaku`` が指す値は、注文の合計金額に等しくなります。

練習問題
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ここで見た例にならって、あなたの直近の注文をリストで扱い、合計金額を算出してみてください。

.. answer::

    この練習問題の解答は省略します。
    レストランの例を参考に取り組んでみてください。

.. advanced:: 「配列」という言葉

    .. 手元の『基本情報技術者教科書 平成28年度』
        「配列は、同じデータ型の複数の変数を連続して配置するデータ構造です。
        各変数を要素と呼び、（以下略）」(p.97)

    プログラミングには「配列（はいれつ）」という言葉があります。
    配列は複数の値をまとめて扱うために使われます。

    配列は、この章で紹介した **リストとほぼ同じ** ものです。
    配列とリストの違いは、配列では要素は同じ型に限るという点です。
    プログラミングに取り組む中で配列という言葉に出会ったら、リストに読み替えてください。

    .. リストは「他の言語で言う配列と同様のもの」
        https://docs.python.org/ja/3/glossary.html#term-list
        ミュータブル（idを変えることなく値を変更できる）なシーケンス（インデックスアクセスでき、長さを持つ）

    .. https://docs.python.org/ja/3/faq/programming.html#how-do-you-make-an-array-in-python
        「リストの時間計算量は C や Pascal の配列と同じです。大きな違いは、Python のリストは多くの異なる型のオブジェクトを含めることです」

.. advanced:: 複数の値のもう1つの扱い方、タプル

    リストと似た値に **タプル** があります。
    リストでは複数の値を ``[]`` で囲みましたが、タプルは ``()`` で囲みます。
    ``()`` で囲むことで、作る値がタプルだと指定しています。

    .. code-block:: python

        >>> (1, 2, 3)
        (1, 2, 3)

    タプルの型は、要素の型によらず、常に ``tuple`` です。

    .. code-block:: python

        >>> type((1990, 175.2, "nikkie"))
        <class 'tuple'>

.. advanced:: タプルとリストの共通の性質

    * タプルも要素に **順番** を持ちます（左が先頭、右が末尾）
    * ``for`` 文でタプルの要素を **反復** できます
    * 要素数を **長さ** として持ちます
    * ``-長さ`` 以上、``長さ-1`` 以下の範囲の **インデックス** で要素を指定できます
    * インデックスに指定できる範囲の外を指定した場合、処理系は ``IndexError`` を出します

    .. code-block:: python

        >>> gakki_tuple = ("チューバ", "ユーフォニアム", "コントラバス")
        >>> gakki_tuple[-2]  # ((後ろから2つ目の要素を指定))
        'ユーフォニアム'

    リストのインデックスで試したことを、タプルでも試してみてください。

.. advanced:: タプルは変更できない！（リストとの違い）

    タプルは、**要素への代入、要素の追加、削除ができません**。
    例えば、インデックスが指す要素に代入しようとすると、処理系はエラーを出します。

    .. code-block:: python

        >>> gakki_tuple[1] = "ユーフォ"
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: 'tuple' object does not support item assignment

    ``TypeError`` は、タプルは要素への代入ができない（does not support item assignment）旨を表示しています。
    代入のほか、``append`` で要素を追加したり、``pop`` で削除することもできません（そのようなメソッドが用意されていません）。

.. column:: リストとタプルの使い分け

    .. https://pycamp.pycon.jp/textbook/4_collections.html#index-7
        リストとの違いと使いどころ
        「タプルは、関数の戻り値や不変としたい設定用の値に使います。」

    .. タプルも `+=` で擬似的なappendは可能

    .. https://docs.python.org/ja/3/faq/programming.html#how-do-you-make-an-array-in-python
        「ミュータブルな必要があるなら、タプルではなくリストを使いましょう」

    リストもタプルも ``for`` 文で繰り返したり、インデックスで要素を指定したりできます。
    使い分けに影響するのは、変更できる必要があるかどうかです。
    私は、**変更しない複数の値をタプルで** 扱い、**変更する可能性がある複数の値をリストで** 扱っています。

    リストは空のリストに繰り返し ``append`` する例を紹介したように、変更できるのが利点です。

    タプルは、用意した後に変更しない（または変更すると困る）複数の値を扱う際に利用します。
    変更しないタプルにすることで、変更を意図していないことを示す意図もあります。

.. advanced:: 複数の返り値を返す関数は、タプルを返している

    :numref:`define_functions` 「:ref:`define_functions`」の発展で
    「関数の返り値は複数あってもいい」と紹介しました。
    返り値をカンマで区切って書いたとき、実は **タプルを返して** いるんです。

    .. doctestを返すための準備
        >>> def aisatsu_bun_kai(namae):
        ...     bun = namae + "さん、ごきげんよう"
        ...     return bun, len(bun)

    .. code-block:: python

        >>> kaerichi = aisatsu_bun_kai("nao_y")
        >>> type(kaerichi)
        <class 'tuple'>
        >>> kaerichi
        ('nao_yさん、ごきげんよう', 14)

    複数の返り値を持つ関数の返り値を変数に代入するとき、
    返り値の数と同じだけ変数を用意した場合は、それぞれの値が変数に代入されます。
    変数を1つだけ用意した場合は、**返り値を並べたタプル** が代入されます。

.. advanced:: 同じ値を指すことの不思議（数値や文字列の場合）

    .. https://speakerdeck.com/mizzsugar/bian-shu-nibian-shu-wodai-ru-sitara?slide=14
        変数 -> ミュータブルなオブジェクト（オブジェクト自体を変えられない）
                ミュータブルなオブジェクトに対しては、appendや中身を変えるという操作ができる
                2つの変数で同じオブジェクトを指すときに中身を変えると、どちらの変数からも指す値が変わって見える
                2つの変数で別々のオブジェクトを指すこともできる
        変数 -> イミュータブルなオブジェクト（オブジェクト自体を変えられる）
                イミュータブルなオブジェクトに対しては、appendや中身を変えるという操作ができる
                2つの変数で同じオブジェクトを指すとき、新しい値を作って指すものを変えるだけ（中身を変えることができない）

    ``変数2 = 変数1`` という文で、変数1が指す値そのものを変数2も指すのでしたね。

    復習として、整数の場合を見てみましょう（文字列の場合も同じです）。

    .. code-block:: python

        >>> a1 = 4
        >>> a2 = a1
        >>> a1
        4
        >>> a2
        4

    ``a1`` が指す ``4`` という値を ``a2`` も指しています。
    ここで ``a1`` が別の値を指すように変更しても ``a2`` は変わりません。

    .. code-block:: python

        >>> a1 += 1
        >>> a1
        5
        >>> a2
        4

.. advanced:: 同じ値を指すことの不思議（リストの場合、数値や文字列と違う！）

    ``変数2 = 変数1`` は ``変数1`` が指す値がリストだと、**リスト自身を変更できる** ために、ちょっと不思議なことが起こります。

    .. code-block:: python

        >>> a = [1, 2, 3]
        >>> b = a
        >>> a
        [1, 2, 3]
        >>> b
        [1, 2, 3]

    ``a`` が指すリストを ``b`` も指しています。
    ``a`` が別のリストを指すように変更（例 ``a = [4, 5]``）しても ``b`` は変わりません（整数で見たときと同じです）。

    違いは、``a`` が指す **リストそのものを変更** する場合です（``append`` メソッドなど） 。
    これはリストのときに限った話で、数値や文字列の場合は、値そのものを変更することができません
    （``4`` という値はどこまでいっても ``4`` です）。

    ``a`` の指すリストで、インデックス ``1`` が指す値を更新してみましょう。

    .. code-block:: python

        >>> a[1] = 102
        >>> a
        [1, 102, 3]

    ``a`` と ``b`` は **同一のリスト** を指しているので、リストが変更されたことを変数 ``b`` の側からも確認できます。

    .. code-block:: python

        >>> b
        [1, 102, 3]

    変数 ``a`` と変数 ``b`` が **指すリストが同じ** というのがポイントです。
    逆に、 ``b.append(104)`` のようにリストを変更した場合も、``a`` の側からも変更が確認できます。

    .. figure:: images/10/10-4_reference_same_list.drawio.png
        :align: center
        :width: 80%

        ``a`` と ``b`` が指す共通のリストの変更となる

.. advanced:: 2つの変数が同じリストを指さないようにする

    1つ前の発展の ``b = a`` の例は、**同じリストを指さなければ起こりません**。

    続く例の ``c`` と ``d`` の指すリストは、個々の要素が同じですが、**別々に作られたのでリストとしては別物** です。

    .. code-block:: python

        >>> c = [4, 5]
        >>> d = [4, 5]
        >>> c[0] = 104
        >>> c
        [104, 5]
        >>> d
        [4, 5]

    .. figure:: images/10/10-5_reference_each_list.drawio.png
        :align: center
        :width: 80%

        ``c`` の指すリストのみの変更。``d`` の指すリスト（``c`` と同じ要素）には影響しない

    .. 特殊メソッド__eq__では、2つのリストは等しい（全要素が__eq__で等しい）
        idが異なるので同じリストではない（b = aの場合はidが同じ）

    ``b = a`` の例は、**1つのリストを複数の変数で指して使いたい場合** の書き方です。
    同じ要素のリストの **片方についてだけ操作したい場合** は、変数 ``c`` や ``d`` の例のように **リストをそれぞれ代入** しましょう。
    ``リスト.copy()`` というメソッドを使っても同じ結果になり、片方のリストだけを操作できます。

    .. list-table:: リストに対して使える、コピーした別のリストを用意する関数
        :align: center

        * - 箱の名前
          - ``copy``
        * - 箱は何をするか
          - リストをコピーし、同じ要素からなる別のリストを作る
        * - 箱に入れるもの
          - なし
        * - 箱から出てくるもの
          - コピーしたリスト

    .. copyメソッドは浅いコピーを返す（全部を指定したスライス a[:] と同じ）
        https://docs.python.org/ja/3/tutorial/datastructures.html#more-on-lists
    .. 「リストの浅いコピーはリスト全体を指すスライス」
        https://docs.python.org/ja/3/library/copy.html
    .. aをリストした時に、a.copy() は a[:] と等価
        https://docs.python.org/ja/3/tutorial/datastructures.html

    .. code-block:: python

        >>> e = [1, 2, 3]
        >>> f = e.copy()
        >>> e
        [1, 2, 3]
        >>> f
        [1, 2, 3]
        >>> e[1] = 102  # ((変数fが指すリストには影響しない))
        >>> e
        [1, 102, 3]
        >>> f
        [1, 2, 3]

    .. TODO: variable章 3節コラムの累算代入の話題に言及したい
