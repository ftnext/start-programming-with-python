====================================
数と文字を扱ってみよう
====================================

.. 前提：プログラミング＝Pythonを書くこと としています

初めてのプログラミングという大きな挑戦を前に、ワクワクする気持ちもあれば、「自分にできるのだろうか」という不安もあると思います。
分からないことにぶつかって自信をなくしてしまうこともあるでしょう。
ですが、それは誰しも通る道です。
この本を書いている私たちも初めてのプログラミングという道を通ってきました。
全部分からなくても大丈夫です。
分からないところをときに飛ばしたり、ときに戻ったりしながら、一歩一歩分かることを増やしていきましょう。

数値
====================================

.. 身近な数値計算として、割り勘、買い物の合計額を用意

練習問題
------------------------------------

練習問題1
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

著者たちを含むプログラマー4名で食事に行ったところ、合計金額が税込みで5070円でした。
割り勘にすると、1人あたりいくらでしょうか。

.. column:: 解答

    合計金額を人数で割って、1人あたりの金額を求めます。

    .. code-block:: python

        >>> 5070 / 4
        1267.5

    0.5円は金額としてはありえないため、切り上げて1人あたり1268円です。
    1円単位は持ち合わせがない場合が多いので、1人1300円とするのが現実的でしょう。

練習問題2
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

余裕がある方は以下も考えてみてください。

(2)(1)の支払いをスマホ決済にしたところ、キャンペーンで金額の10%がポイントとして付与されました。
ポイント分を割引と考えて差し引くと、都合いくら支払ったことになるでしょうか。

(3)月日が流れ、消費税率が10%に上がりました。(1)の合計金額はいくらでしょう。

.. column:: (2)の解答

    まずは付与されたポイントを求めましょう。

    .. code-block:: python

        >>> 538 * 0.1
        53.800000000000004

    還元額の端数の扱いも消費税の場合と同様に切り捨てとします。
    すると、還元額は53円です。

    還元額を差し引いた支払金額は、

    .. code-block:: python

        >>> 538 - 53
        485

    485円と求めることができました。

.. column:: (3)の解答

    消費税率を10%として(1)の計算を行います。

    .. code-block:: python

        >>> (279+100+120) * (1+0.1)
        548.9000000000001

    小数点以下を切り捨てて、消費税率10%の場合の合計金額は548円です。
    消費税率が2%上がったことで、問題のケースでは10円支払額が増加しました。

.. 演算子 % はFizzBuzzで初出とする

.. column:: 四則演算以外も計算できる

    プログラミング言語には四則演算以外の演算子も持っています。
    Pythonでは ``%`` という演算子を使うことで、数を割った余りを求めることができます。

    .. code-block:: python

        >>> 60 % 24
        12

    ``60 = 2 × 24 + 12`` ですから、余りは12となり、人間が行う計算とも一致しますね。

文字列
====================================

.. column:: 文字列を表すときに、シングルクォートとダブルクォートの両方が使えるのはなぜ？

    文字列にシングルクォートやダブルクォートを含められるようにするためです。
    例えば、rock'n'roll（ロックンロール）のようにシングルクォートを含んだ文字列を作るときは、ダブルクォートで囲みます。

    .. code-block:: python

        >>> "rock'n'roll"
        "rock'n'roll"

    ダブルクォートを含んだ文字列を作りたいときは、シングルクォートで囲みます。

文字列の計算、計算の順番
------------------------------------

文字列の「掛け算」
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

「掛け算」による文字列の繰り返しは、例えばメールの署名を設定するときに使えます。
本文との区切り線を作るために ``'ー'`` という記号を何文字もキーボードから打つのは大変でしょう。
入力した記号を目で数えるのは面倒ですし、数え漏れも発生しやすいです。
記号を繰り返す際にPythonを使ってみましょう。

.. code-block:: python

    >>> "ー" * 20
    'ーーーーーーーーーーーーーーーーーーーー'

この区切り線を使って、以下のようなメールの署名を設定できますね。
ここで少し本から離れて、ご自分のメールの署名にPythonを試してみてはいかがでしょうか。

.. code-block:: none

    ーーーーーーーーーーーーーーーーーーーー
    nikkie

    MAIL: xxx@gmail.com
    ーーーーーーーーーーーーーーーーーーーー

.. ハイライトする言語にnoneを設定（doc8のwarningは無視）
    https://www.sphinx-doc.org/ja/1.6/markup/code.html

.. 本の中で文字列の計算の優先順位を使っている箇所がないので、紙面から削除する

計算の順番
------------------------------------

「足し算（連結）」と「掛け算（繰り返し）」を学んだ後は、演算子の優先順位を確認しておきましょう。
``*``　が ``+`` よりも **先** に評価されます（数値の四則演算と同じですね）。

.. code-block:: python

    >>> "威風" + "堂々" * 2
    '威風堂々堂々'

``"堂々" * 2`` が先に評価されて ``"堂々堂々"`` ができ、 ``"威風"`` と連結されて上記の結果となります。

文字列の連結を先に評価したい場合は、カッコ ``()`` を使います（数値の足し算を先に計算したいときと同じですね）。

.. code-block:: python

    >>> ("威風" + "堂々") * 2
    '威風堂々威風堂々'

``("威風" + "堂々")`` が先に評価されて、 ``"威風堂々"`` の2回の繰り返しとなりました。

練習問題
--------------------------------

ここまで学んだことを使うと、複数通りのやり方で行うことができます。
2つやり方を見つけられたらすごいです！

.. column:: 解答

    ``*`` で繰り返すと、プログラムを書く量はわずかで、少ない手間でやりたいことを達成できます。

    一方、ここまでで覚えたことを思い出して、次の方法が浮かんだ方もいるかもしれません。

    .. code-block:: python

        >>> "万歳！" + "万歳！" + "万歳！" + "万歳！" + "万歳！" + "万歳！" + "万歳！" + "万歳！" + "万歳！" + "万歳！"
        '万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！'

    やや手間はかかりますが、やりたいことを達成できました。

    また、計算の優先順位を思い出すと、万歳！を5回繰り返してから連結したり、2つ連結してから5回繰り返したりしても、やりたいことは達成できます。

    .. code-block:: python

        >>> "万歳！" * 5 + "万歳！" * 5
        '万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！'

    .. code-block:: python

        >>> ("万歳！" + "万歳！") * 5
        '万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！'

    ずるいと思われるかもしれませんが、実は ``+`` や ``*`` を使った計算をしなくても書けます。

    .. code-block:: python

        >>> "万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！"
        '万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！万歳！'

練習問題でやりたいことを達成するためのいくつかの方法を見てきました。
この中では最初に示した ``"万歳！" * 10`` が一番手間が少ないという点には皆さん同意していただけるでしょう。

一般にプログラミングでは、**手間が減る書き方をいい書き方とすることが多い** です。
手間を減らすにはプログラムを簡潔に書く必要があります。
問題によっては簡潔に捉えることに頭を使う必要がありますが、簡潔に書けたときの気持ちよさは言葉で言い表し難いものがあります。

この練習問題を ``"万歳！" * 10`` 以外で解答した方は不正解ではありません。
やりたいことが達成できているので正解です。
安心してください。
一番手間が少ない ``"万歳！" * 10`` という方法は頭の片隅に置いておきましょう。
次に同じような問題を見かけたときに試してみてください。
次の問題で100回繰り返すことがやりたいことだとしたら、 ``"万歳！" * 10`` という書き方がきっと活かせるはずです。

データの種類（型）
====================================

データの種類を指定する
--------------------------------

.. コンピューターを動かすよりもPython処理系に処理させるで書き進めているので一時退避

人間の場合は「3と3を足して」と言ったら、数値の足し算だと思って「6」と結果を返すでしょう。
それに対して、コンピューターに「3と3を足して」と指示しても、コンピューターはそれ以上計算できません。
「3と3を足して」では、「3」を数値として扱うのか、文字列として扱うのか判断できないからです。

``3 + 3`` と書いたら、数値の ``3`` と数値の ``3`` を足すことをコンピューターに指示します。
``"3" + "3"`` の場合は、文字列の ``"3"`` と文字列の ``"3"`` の足し算を指示したことになります。

.. 直前の説明の重複になっている気がしてきたので、退避して本文から削除する

先ほどの2問を思い出すと

- ``3 + 3`` という式は、数値の ``3`` と数値の ``3`` の足し算として評価されます。
- ``"3" + "3"`` の場合は、文字列の ``"3"`` と文字列の ``"3"`` の足し算として評価されます。

.. 逆説的な書き方が伝わらないようなので退避して書き直し

``3 + "3"`` は型の組合せが不適切なので、常にTypeErrorとなります。
つまり、計算できないということです。
実はこれが型の利点なのです。

型は **データに課される制約** です。
3というデータだと曖昧ですが、数値の3や文字列の3のように制約があることで、3というデータでできる計算とできない計算が明確に分かります。
制約という言葉にはできることが制限されるマイナスのイメージもあるかもしれませんね。
ですが、プログラミングにおいては、型という制約は利点をもたらします。

初めてのエラー：データの種類が食い違ったとき
----------------------------------------------------------------

.. 2つのコラムを退避した。ファイル名変更、電話取次ぎ、ブラックジャックで小数は使わないので、紹介程度に留め、簡潔にまとめたい
    数値の型についてもう少し（整数と浮動小数点数）
    浮動小数点数の不思議

.. column:: 数値の型についてもう少し（整数と浮動小数点数）

    数値は小数点を含むか含まないかで2つの型に分かれています。
    小数点を持たない数（例えば、-4, 0, 123）は **整数** （Pythonではint）という型になります（整数を表すintegerに由来します）。
    小数点を持つ数（例えば、-5.6, 0.9, 34.0）は **浮動小数点数** （ふどうしょうすうてんすう。Pythonではfloat）という型です。
    浮動小数点数は小数点を固定しない（浮動）で表すということです（小数点を固定して小数を表す方法もあります）。

    1節の数値で見た例は、整数（int）の四則演算でしたね。
    浮動小数点数（float）も四則演算ができます。
    半径4.5cmの円の面積を求める例です。

    .. code-block:: python

        >>> 3.14 * 4.5 * 4.5
        63.585

    また、Pythonでは整数と浮動小数点数の間でも四則演算ができます。
    整数と浮動小数点数を計算した結果は、浮動小数点数になります。
    マラソンコースを分担して走っているときに、最終走者の走る距離を求めます。

    .. code-block:: python

        >>> 42.195 - (12 + 15 + 7)
        8.195
    
    Pythonの特徴は、整数どうしの割り算の結果が浮動小数点数になることです。
    プログラミング言語によっては、割り算の結果が異なる挙動になります。

    このコラムでは、Pythonで扱う数値について、整数と浮動小数点数という2つの型があると紹介しました。
    Python以外のプログラミング言語でも、整数と浮動小数点数は型として区別されます。
    また、整数や浮動小数点数の中にいくつかの分類を持つプログラミング言語もあります。

.. ref: https://docs.python.org/ja/3/library/stdtypes.html#typesnumeric

.. column:: 浮動小数点数の不思議

    浮動小数点数は、私たちがふだん扱う小数点を持つ数と挙動が異なります。
    試しに0.1を3回足してみましょう。
    私たちは普段 0.1+0.1+0.1 は0.3と等しいと扱いますよね。

    .. code-block:: python

        >>> 0.1 + 0.1 + 0.1
        0.30000000000000004

    0.3よりわずかだけ大きな値となりました。
    同様の表示は1節の練習問題でも見ていますね（``53.800000000000004``）。
    これはコンピューターが小数点を持つ数を厳密には扱えずに、**近似している** ためです。

    実は0.1をコンピューターが扱おうとすると、0と1の並びになるのですが、無限に続いてしまいます。
    コンピューターの部品は有限なので、やむなく無限に続く数を途中で打ち切って近似しているのです。

    言い換えると、対話モードで0.1と入力すると0.1と表示されますが、

    .. code-block:: python

        >>> 0.1
        0.1

    近似された値なので、厳密な0.1ではありません。
    そのため、0.1を3回足しても、0.3にはならなかったわけです。

    浮動小数点数が近似になるというのは、プログラミング言語によらず、コンピューターについてまわる問題です。
    プログラミングで浮動小数点数の計算結果を比較する場合は、差が極めて小さければ等しいものと扱います。
    先ほどの例の ``0.30000000000000004`` も ``0.3`` との差が極めて小さいですからね。

.. ref: https://docs.python.org/ja/3/tutorial/floatingpoint.html

.. エラーに慣れてみる例はカットした（浮動小数点数についてさっとしか触れていないというのもある）

.. column:: エラーは怖くない

    この節では初めてエラーを経験しました。
    エラーは英語でずらずらと書かれているので、「不気味なもの」「よく分からないもの」と不安に思うかもしれませんね。
    そこでこのコラムでエラーについて知って、不安を少しでも払拭しましょう。

    まず、エラーが表示されても、何かが壊れたわけではないので安心してください。
    **実行中に問題が起こったことを示しているだけ** で、Pythonの対話モードは ``>>>`` と次のプログラムの入力を待っています。

    次に、エラーには、**発生した問題の情報** が英語で書かれています。
    英語のエラーを読むと「プログラムのどこで問題が発生したか」や「どんな問題が発生したか」が分かります。
    問題が詳細に分かれば、「なぜ問題が発生したか」と原因を考えることができます。
    そして、原因を特定したら、解決策を試すことができます。
    つまり、**エラーは発生した問題を解決するためのヒントになる** のです。

    エラーが表示されても何かが壊れたわけではないので、エラーは怖がらずにどんどん出しましょう。
    エラーに慣れるために、エラーが発生する次のコードのいずれかを実行してみてください。

    1. 浮動小数点数 + 文字列： ``1.5 + '堂々'``
    2. 文字列 + 整数： ``'吾輩は' + 1``
    3. 文字列 × 浮動小数点数： ``"万歳！" * 2.5``
    4. 文字列 × 文字列： ``"万歳！" * '三唱'``

    いずれの場合もTypeErrorが発生します（以下は3の例）。

    .. code-block:: python

        >>> "万歳！" * 2.5
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: can't multiply sequence by non-int of type 'float'

    「can't multiply sequence by non-int of type 'float'」とは、floatのようにintではない型（non-int）を文字列に掛けられない（can't multiply）ということです
    （シーケンス sequence とは、文字列では文字が *順番をもつ* という性質を抽象的に表した表現です）。
    本文中で見たのと同じく、このTypeErrorは計算できないということを示すものです（エラーが表示されないようにすることはできません）。 
    
    この本ではこの後もどんどんエラーを出していきます。
    エラーを読んで、発生した問題を掴むようにし、 エラーの原因の問題を解決する方法を覚えるようにしましょう。
    エラーの経験が増えると、「これはあのときに見たエラーだ。たしかああしたら解決したから、今回はここをこう変えたら直るはず」と、**経験したエラーをヒントに、自分で問題を解決することができる** ようになります。

    私（nikkie）は先輩から「エラーは怖がらずどんどん出そう。エラーを見た数だけ、そして、その原因を解決した数だけ、プログラミングは上達する」という言葉を教わりました。
    この言葉は、エラーを見ても原因がわからず挫けそうになるときに支えとなりました。
    「知らないエラーを見た分だけ、これまでより前進した」と。
    皆さんにもエラーは上達のきっかけととらえてみていただけると嬉しいです。
