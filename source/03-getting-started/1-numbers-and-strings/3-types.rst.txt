.. _value_integer_string__types:

値には種類がある：型
====================================

.. 「データ」という語はfile_cmd章と異なる意味になってしまうので「値」に統一した
    （file_cmd章ではデータ＝ファイル。ゲームのセーブデータのイメージ）
    値を使っている箇所：https://docs.python.org/ja/3/tutorial/introduction.html#numbers
    参考情報：手元の辞書では、データ＝コンピューターの処理対象。データには数値や文字列などがある
    「コンピューターの処理の対象となる事実。状態・条件などを表す数値・文字・記号。」

この節では、数値と文字列は *種類が異なる* ことを見ていきます。

.. 値という言葉が指すものはこの後増える（例：リスト）が、ここでは数値と文字列しか知らないので、列挙して定義した

これまでに出てきた数値や文字列のことをまとめて、「値」（あたい）と呼びます。
実はプログラミングでやっていることは、**プログラマーは値と演算子から式を作り**、それを **処理系に評価させ** て、**結果の値を得る** ことです。

.. figure:: images/1/1-4_value_operator_expression_evaluation.png
    :align: center
    :width: 70%

    プログラミングでやっていること

値の種類を指定する
--------------------------------

復習を兼ねて、次の式を評価した結果は何でしょうか？

1. ``3 + 3``
2. ``"3" + "3"``

.. answer::

    1は *数値* の ``3`` と ``3`` の足し算ですね。

    .. code-block:: python

        >>> 3 + 3
        6

    2は *文字列* の ``"3"`` と ``"3"`` をつなげます。

    .. code-block:: python

        >>> "3" + "3"
        '33'

この2例は、プログラミングでは **値の種類を明確にして記述する** ことを示しています。

- 単に ``3`` と書いたら **数値**
- ダブルクォートを付けて ``"3"`` と書いたら **文字列**

と **種類を書き方で指定** しているのです。

.. 上記でリテラルという概念に言及（ただし、リテラルという言葉は紹介しない）
    https://docs.pyq.jp/python/library/literal.html
    https://docs.python.org/ja/3/reference/lexical_analysis.html#literals
    リテラルはトークンの種類（トークンの種類には他に演算子がある）
    この節で扱っているのは、「文字列リテラル」「整数リテラル」
    https://docs.python.org/ja/3/reference/expressions.html#literals
    > リテラルは全て変更不能なデータ型に対応します。
    https://docs.python.org/ja/3/library/stdtypes.html#numeric-types-int-float-complex
    組み込み型の中の数値型のintは、数値リテラルによって生成される
    https://docs.python.org/ja/3/library/stdtypes.html#text-sequence-type-str
    組み込み型の中のテキストシーケンス型（str）は、文字列リテラルによって生成される（数値リテラルと書き方が異なる）

.. ドキュメントではデータ型（data types）と書かれることも多い印象だが、単に型とした

**値の種類** をプログラミングでは「型（かた）」と言います。
この本を読み進める中で、数値や文字列を表す型の他に、日付などの型と出会います。お楽しみに。

初めてのエラー：処理できない型の組合せのとき
----------------------------------------------------------------

では、``3 + "3"`` のように、数値（整数）と文字列の「足し算」の式を、実行したら（プログラミング言語処理系に処理させたら）どうなるでしょうか。

.. code-block:: python

    >>> 3 + "3"
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for +: 'int' and 'str'

式の評価結果ではなく、文字が大量に表示されましたね。
結果が出ていませんが、あなたの **コンピューターやインストールした処理系が壊れたわけではない** ので安心してください
（対話モードは ``>>>`` と次のプログラムの入力を待っていますね）。

Errorという文字は、処理系がエラーを出したことを表しています。
式 ``3 + "3"`` の評価で出たエラーの情報は、
最後の行の「TypeError: unsupported operand type(s) for +: 'int' and 'str'」に示されています。

``int`` と ``str`` は型の名前です（それぞれ英単語integer（整数）、string（文字列）に由来します）。
数値 ``3`` の型は ``int``、文字列 ``"3"`` の型は ``str`` です。
つまり、整数と文字列とに ``+`` を使った式はサポートされていない（すなわち、評価できない）ということです。

.. operand: 被演算子　operator: 演算子（ここでは+）

.. TypeError https://docs.python.org/ja/3/library/exceptions.html#TypeError
    > 組み込み演算または関数が適切でない型のオブジェクトに対して適用された際に送出されます。

``TypeError`` は型についてのエラーです（プログラミングにおける型は英語でtypeです）。
``整数 + 文字列`` という式は、**適切ではない型の組合せのために評価できない** ことを表しています。
式 ``3 + "3"`` に対し、処理系は **常に** ``TypeError`` を出します。
つまり、整数と文字列の「足し算」はできません。

この例のように、演算子がサポートしない型があり、そのために評価できない式があります。
型は **式の評価に制約を課し** ているわけです。
プログラマーは人間ですから、見落としや思い込みのために、処理系が評価できないプログラムをときどき書いてしまいます。
そんなプログラムに処理系はエラーを出すので、プログラマーは自分のミスに気づけます。

.. column:: エラーは怖くない

    初めてエラーを経験しましたね。
    エラーは英語でずらずらと書かれており、「不気味なもの」「よく分からないもの」「自分を否定された」と
    あまりいい印象ではないかもしれません。

    私は先輩から「エラーは怖がらずどんどん出そう。
    エラーを見た数だけ、そして、その原因を解決した数だけ、プログラミングは上達する」と教わりました。
    この言葉は、エラーを見ても原因が分からずくじけそうになるときに支えとなりました。

    スポーツの試合でのエラーは失点につながってしまう避けたいものですよね。
    ところが、プログラミングでのエラーは、どんどん経験したい **上達のきっかけ** です。
    プログラミングのエラーは間違いではなく、**皆さんの今後のプログラミングに役立つ財産** です。

    皆さんに上達してほしいので、この本ではこの後もどんどんエラーを出します。
    合わせてエラーの解説もしますので、**エラーの原因を解消する方法** を理解しましょう。
    エラーの経験を積み重ねると、「これはあのときに見たエラーだ。
    あのときはああしたら解決したから、今回はここをこう変えたら直るはず」と
    経験したエラーをヒントに、自力で解決できるようになります。

    .. この先の話題として「エラーが解決できると処理系とペアになってプログラミングしている感覚」
        この本でそこまで到達するのは厳しいと思うのでカット

.. advanced:: エラーの読み方

    .. 申し送り 対話モードしか知らないので、ファイルを実行したときのエラーまでカバーしきれていない懸念あり

    エラーには **処理系がエラーを出したときの情報** が英語で書かれています。
    これを手がかりにすると、エラーは、**エラーを解決するためのヒント** になります。

    .. code-block:: python

        >>> 3 + "3"
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: unsupported operand type(s) for +: 'int' and 'str'

    エラーとして表示されるのは、Traceback（トレースバック）です。
    次の2つに着目しましょう。

    * ``line`` の表示（プログラムの何行目で、処理系がエラーを出したか）
    * 最後の行（処理系はどんなエラーを出したか）

    「**line 1**」とあるのは、入力したプログラム（``3 + "3"`` の1行）のうち、1行目の実行で処理系がエラーを出したということです。
    何行目かを手がかりにすることで、**原因箇所** が特定できます
    （:numref:`in_order` 「:ref:`in_order`」以降は、何行もあるプログラムを書きますよ）。

    **最後の行** には ``TypeError`` と出ていて、エラーが出た原因も示されています（本文で示したとおりです）。

    こうして、プログラムの **どこが原因で、どんなエラーが出たか** 特定できます。
    その後は解決策を試しましょう。
    エラーの経験を積み重ねると、過去のエラーの経験から解決策がいくつか浮かぶようになります。

    なお、プログラミングでは、エラーのことを「例外」とも言います。

.. column:: コマンドラインの履歴を使おう

    .. file_cmd 章にて「ターミナル、コンソール、コマンドラインは同じ意味」

    ``3 + "3"`` を実行して、処理系がエラーを出したとき、もう皆さんはその理由が分かりますね。
    「文字列の ``"3"`` どうしをつなげようとしていたのに、1つ目の3を数値にしてしまっていた」と気づくかもしれません。

    エラーが出た後、プログラムを初めから入力し直すのは少し面倒ですよね。
    実は **上矢印キー** （↑）を1回押すと、直前に入力したPythonのプログラム ``3 + "3"`` が現れます。
    左矢印キー（←）・右矢印キー（→）でカーソルを左右に動かして ``"3" + "3"`` のように修正できます。

    このようにプログラミング言語処理系は **履歴** を持っています。
    またシェルにも履歴があり、2つの履歴は分かれています。

    .. list-table:: コマンドラインの履歴
        :align: center

        * - 履歴の対象
          - 説明
          - 例
        * - シェル
          - コマンドの履歴
          - ``python``, ``ls``
        * - 処理系（対話モード）
          - 対話モードに入力されたプログラムの履歴
          - ``3 + "3"``

    上矢印キー（↑）を押すことで、最新から過去へと辿ることができます。
    もし過去に戻りすぎてしまったときは下矢印キー（↓）を押してください。

.. advanced:: プログラミングにおける小数

    数値は小数点を含むか含まないかで2つの型に分かれています。
    小数点を持たない数（例えば、-4, 0, 123）は 整数（``int``）という型です。
    小数点を持つ数（例えば、-5.6, 0.9, 34.0）は **浮動小数点数** （ふどうしょうすうてんすう。``float``）という型です。

    浮動小数点数は、皆さんの知っている小数とは少し異なります。
    数値の練習問題で合計金額が ``538.9200000000001`` となりましたね。
    電卓を使って計算すれば 538.92 と求まります。

    コンピューター内部では **どんな値も0と1の並び** で表されます。
    小数点を持つ数も0と1の並びで表しますが、小数点を持つ数そのものとは一致しません。
    正確に表そうとすると0と1が無限に続くのですが、コンピューターの大きさは決まっていますから、**やむなく打ち切る** ためです。

    例に出した練習問題では ``0.08`` が途中で打ち切られた値です。
    これは正確な0.08ではないため、評価結果が ``538.9200000000001`` と端数を含む値となるのです。
    なお、これでは金額を計算するときに不便なので、プログラミングでも電卓と同じように計算する仕組みが用意されています
    （この本を読み進めると *標準ライブラリ* が登場します。その中の ``decimal`` モジュールを使います）。

    .. ref: https://docs.python.org/ja/3/tutorial/floatingpoint.html
        「表示された結果が正確に 1/10 であるように見えたとしても、
        実際に格納されている値は最も近く表現できる二進小数であるということだけは覚えておいてください。」

    .. https://docs.python.org/ja/3/library/decimal.html
        >>> from decimal import Decimal
        >>> (279 + 100 + 120) * (1 + Decimal("0.08"))
        Decimal('538.92')
