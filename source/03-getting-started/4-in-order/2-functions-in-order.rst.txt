ファイルに書いた関数
============================

関数を書いたファイルの実行も、順次で説明されます。
ですが、関数の呼び出しは、ファイルを *遡っているように見え* ます。
本節で、関数を書いたファイルについて、処理系の動きを頭の中で再現できるようになりましょう。

ファイルで挨拶を表示する関数を作る
----------------------------------------------------------------

関数を使ったファイル ``aisatsu.py`` を書いていきましょう。

:numref:`define_functions` 「:ref:`define_functions`」で作った、引数に指定した人への挨拶を表示する関数を
``aisatsu`` という名前で定義します。

.. list-table:: 指定した人への挨拶を表示する関数
    :align: center

    * - 箱の名前
      - ``aisatsu``
    * - 箱は何をするか
      - 「〇〇さん、ごきげんよう」と挨拶を表示する
    * - 箱に入れるもの
      - 文字列（「〇〇」の部分に入る人の名前）
    * - 箱から出てくるもの
      - なし

.. literalinclude:: codes/4-2/aisatsu.py
    :language: python
    :caption: aisatsu.py
    :pyobject: aisatsu
    :linenos:

対話モードと同様、ファイルでも **インデントが必要** です。

このファイルを実行しましょう（実行方法は前節を参照してください）。
どうなると思いますか？

.. code-block:: shell

    > python aisatsu.py
    >

おや、「ごきげんよう」という挨拶は表示されませんでした。
処理系がエラーを出したわけではないですね。
では、なぜ表示されなかったのでしょうか。

プログラミングで何かがうまくいかない状況に陥ったら、**過去にうまくいった状態と今のうまくいかない状態を比較** します。
対話モードでは挨拶が表示されていましたね。
:numref:`define_functions` 「:ref:`define_functions`」を思い出してみて、何か気づくことはありませんか？

ファイルでも関数の呼び出しが必要
----------------------------------------------------------------

対話モードでは ``aisatsu`` 関数を定義したあと、``aisatsu("susumuis")`` と **呼び出し** ていました。
それに対して、``aisatsu.py`` では、まだ呼び出していません。
ファイルに関数の呼び出しを追加したら、挨拶が表示されそうですね。
この仮説を試してみましょう（変更点は5行目だけです）。

.. literalinclude:: codes/4-2/aisatsu.py
    :language: python
    :caption: aisatsu.py
    :emphasize-lines: 5
    :linenos:

コマンドラインで実行すると、挨拶が表示されます！（仮説は正しく、問題は解消しました！）

.. code-block:: shell

    > python aisatsu.py
    susumuisさん、ごきげんよう
    >

関数を含むファイルの読み方
----------------------------------------------------------------

処理系が ``aisatsu.py`` をどのように処理するか、見ていきましょう。
順次により、ファイルは **1文目から順番に実行され** ます。

1. 処理系は1,2行目の ``aisatsu`` 関数定義の文を実行します。これで ``aisatsu`` 関数が **使えるようになり** ます

  * この処理では、関数は呼び出されません。使えるようになるだけです

2. 処理系は5行目の文、 ``aisatsu`` 関数の **呼び出し** を実行します

  * 関数呼び出しにより、関数にまとめられた文が1文ずつ順に実行されます（まとめられた文を順次実行します）
  * このファイルでは2行目の文が実行されます（``namae`` には引数 ``"susumuis"`` が代入されます）

.. figure:: images/5/5-16_in_order_function.drawio.png
    :align: center

    関数を呼び出すと、関数に定義した文が順に実行される

関数を2回呼び出すように ``aisatsu.py`` を変えてみましょう。

.. literalinclude:: codes/4-2/aisatsu_call_twice.py
    :language: python
    :caption: aisatsu.py
    :emphasize-lines: 6
    :linenos:

処理系は次の順でプログラムを実行します。

1. 1,2行目の ``aisatsu`` 関数の定義を実行します
2. 5行目の ``aisatsu`` 関数の呼び出しを実行します

  * ``namae`` に ``"susumuis"`` が代入された状態で2行目が実行されます
  * 関数の呼び出しの実行が終わると、続く文の実行に進みます

3. 6行目の ``aisatsu`` 関数の呼び出しを実行します

  * ``namae`` に ``"nao_y"`` が代入された状態で2行目が実行されます
  * 関数の呼び出しの実行が終わると、続く文の実行に進みます（続く文がないのでプログラムの実行終了です）

.. 付けのチェックで対象外にするために noqa を付けた

このことから、関数を書いたファイルを処理系がどう実行するかを知りたいときは、
「関数呼び出しを見つけたら、関数の定義を探す」という読み方になります。  # noqa

.. column:: 関数を定義より先に呼び出すとエラー

    関数を定義する前に関数を呼び出したらどうなるでしょうか。

    .. literalinclude:: codes/4-2/aisatsu_error.py
        :language: python
        :caption: aisatsu.py（処理系がエラーを出します）
        :emphasize-lines: 1
        :linenos:

    定義されていない関数の呼び出しで、処理系は ``NameError`` を出します。
    
    .. code-block:: shell

        > python aisatsu.py
        Traceback (most recent call last):
          File "aisatsu.py", line 1, in <module>
            aisatsu("susumuis")
        NameError: name 'aisatsu' is not defined
        >
    
    定義が1行目より後にありますね。
    1行目の文を処理するときには ``aisatsu`` 関数が使えるようになっていないのです。

    処理系が ``NameError`` を出さなくするために、ファイルでは、関数の **定義を先に、呼び出しを後に** 書きましょう。

練習問題
--------------------------------

以下の「挨拶文を返す関数」が返す挨拶文をコマンドラインに表示するように、``aisatsu.py`` を変更してみましょう。
:numref:`define_functions` 「:ref:`define_functions`」で作った関数から、返り値を少し変えています。

.. list-table:: 挨拶文を返す関数
    :align: center

    * - 箱の名前
      - ``aisatsu_bun``
    * - 箱は何をするか
      - 「〇〇さん、ごきげんよう^o^」という挨拶文を返す
    * - 箱に入れるもの
      - 文字列（「〇〇」の部分に入る人の名前）
    * - 箱から出てくるもの
      - 文字列（挨拶文）

.. answer::

    .. literalinclude:: codes/4-2/aisatsu_practice.py
        :language: python
        :caption: aisatsu.py
        :linenos:

    実行すると、顔文字付きの挨拶が表示されます。
    
    .. code-block:: shell

        > python aisatsu.py
        susumuisさん、ごきげんよう^o^
        >

    6行目の文（式） ``print(aisatsu_bun("susumuis"))`` は、**内側から** 評価されます。
    ``aisatsu_bun("susumuis")`` が評価され、返り値が ``print`` 関数の引数となります。
    
    ある関数の呼び出しを別の関数の引数にするというこの書き方は、プログラムの行数が減るのでたびたび使われます。
    ただし、関数3つ以上でやると読みやすさを損ねてしまいます。
    3つ以上のときは、途中結果を変数に代入する方が読みやすいでしょう。

.. column:: 関数定義の下が2行空いているのはなぜ？

    ``aisatsu.py`` で、``aisatsu`` 関数の定義の下に2行、空の行（空行：くうぎょう）を入れました。
    これはPythonのプログラムを **読みやすく書くための慣習に従っている** ためです。
    :numref:`value_integer_string` 「:ref:`value_integer_string`」のコラムで取り上げた
    演算子の前後の半角スペースと同じで、プログラマーのためのものです。

    空の行の数は処理系には影響しません。
    空の行が3行以上あっても、1行でも、なくても、``aisatsu.py`` を実行すれば同じ結果になります（気になる方は試してみてください）。

    本書では、Pythonのプログラムを読みやすく書くための慣習に従い、本章以降も関数定義の下に2行空行を入れます。

.. column:: エディターだとプログラムが書きやすい

    この章ではエディターを使ってプログラムを書きました。
    「対話モードに慣れてきたのに、なぜわざわざエディターを使うのだろう」と疑問に思うかもしれませんね。
    理由は、対話モードで書くよりも **プログラムを書きやすい** からです。

    例えば関数を作る時、対話モードで改行すると、前の行には戻れません。
    それに対して、エディターでは **入力カーソルを好きな位置に移動** できます（前の行の内容も簡単に直せますね）。

    さらにエディターはプログラムを書きやすくする機能をもっと持っています。
    エディターは、ファイルの拡張子からプログラミング言語を判断します。

    拡張子が ``py`` のファイルについては、必要なところは **自動でインデント** が入ります。
    例えば、関数を定義するとき、``def`` の行をコロンまで入力して改行すると、
    次の行は半角スペース4つ分インデントした位置から始まります。
    タイプする数が減って、プログラムが書きやすいですね。

    .. figure:: images/5/5-15_atom_auto_indent.png
        :align: center

        インデントした位置から入力できる
    
    他にも、変数や関数呼び出しのタイプ中に **候補を提示** したり、変数を別の名前に **一括置換** できたりします。
    Atomを使って快適にプログラミングしたければ、
    自分で調べたり、長くAtomを使っている先輩プログラマーにコミュニティで質問したりしてみてはいかがでしょうか。

.. column:: エディターだとプログラムが読みやすい

    エディターはプログラムを書きやすくするだけではなく、読みやすくする機能も提供します。
    例えば、Atomでは、**値が型ごとに色分け** されます。

    .. figure:: images/5/5-17_atom_highlight.png
        :align: center

        Atomでは、数値はオレンジ、文字列は黄緑、関数は水色で示される
      
    また、プログラミング言語における **キーワード** （Pythonでは ``def`` や ``return`` など） **も色で区別** されます。

    対話モードでは文字の色は全部同じでしたね。
    それと比べると、色分けされたプログラムは読みやすく感じるのではないでしょうか。
